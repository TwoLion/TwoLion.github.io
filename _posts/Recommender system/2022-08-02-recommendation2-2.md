---
layout: single
title:  "이웃 기반 협업 필터링 (2)"
categories: [Recommender System]
tag: [Recommender System]
toc: true
author_profile: true #프로필 생략 여부
use_math: true
---





<br/>

### 1. 이웃 기반 방법론의 평점 예측

<br/>

이웃 기반 방법론의 기본 아이디어는 평점 행렬을 통해 추천을 진행하기 위해 **사용자-사용자 유사도**를 이용하거나 **상품-상품** 유사도를 이용하는 것이다. 이웃 기반 모델에는 두 가지 기본 원칙이 사용된다.



1. 이웃 기반 모델 : **유사한 사용자들은 같은 상품에 대해 비슷한 평점을 준다.**

   ex : 밥과 앨리스가 과거에 비슷한 패턴으로 영화 평점을 부여했다면 밥이 아직 보지 않았던 영화 <터미네이터>의 평점을 예측하기 위해 <터미네이터> 평점을 이미 부여한 앨리스의 평점을 이용할 수 있다.

2. 아이템 기반 모델 : **유사한 상품은 동일한 사용자에게 비슷한 방식으로 평점이 매겨진다.**

   ex : 밥이 이미 평점을 부여한 <에어리언>과 <프레데터> 같은 공상과학영화의 평점을 이용해 영화 <터미네이터>에 부여할 그의 평점을 예측할 수 있다.



가장 근접한 이웃은 행의 유사도만을 가지고 결정하는 classification과는 다르게, 협업 필터링에서는 행 또는 열을 기반으로 최근접 이웃을 찾는 것이 가능하다. 이는 classification에서는 결측 값은 하나의 열에 모여 있지만 협업 필터링에서의 결측값은 행과 열에 퍼져 있기 때문이다.



<br/>

#### 1) 사용자 기반 이웃 모델

<br/>

사용자 기반 이웃 모델에서 사용자 기반 이웃은 **평점 예측이 계산되는 타깃 유저와 유사한 사용자를 찾기 위해 정의된다.** 타깃 유저 $i$의 이수을 찾기 위해서는 다른 모든 사용자와의 유사도가 계산된다. 따라서 사용자가 평가한 평점 간의 유사도 함수가 정의되어야 한다.

$m$ 사용자와 $n$ 상품의 $m\times n$ 평점 행렬 $R=[r_{uj}]$에서 $I_u$를 평점이 사용자 $u$에 의해 지정된 상품 index 집합을 말한다.

ex : $u$번째 사용자가 1, 3, 5번째 상품에 대해서 평점을 부여하였다면, $I_u = \{1, 3, 5\}$가 된다.

위와 같이 $I_u$를 정의하면, 사용자 $u, v$가 동시에 평가한 아이템은 $I_u \cap I_v$로 나타낼 수 있다. 평점 행렬은 희박하게 분포돼 있기 때문에 사실 $I_u \cap I_v$는 공집합인 경우가 많다. 이를 이용하여 사용자 $u, v$ 간의 유사도를 계산할 수 있다.

두 사용자 $u, v$의 평점 벡터(row-wise vecotr in rating matrix) 간의 유사도 $Sim(u, v)$를 구하는 방법 중 하나는 피어슨 상관계수를 사용하는 것이다.  $I_u \cap I_v$가 사용자 $u$와 $v$가 명시한 평점을 가진 아이템의 집합을 표현하기 때문에, 계수는 이 집합에서만 계산된다. 



1. 이미 명시된 평점을 이용해 각 사용자 $u$에 대한 평점의 평균 $\mu_u$를 계산한다.
   $$
   \mu_u = \frac{\sum_{k\in I_u}r_{uk}}{\begin{vmatrix}I_u \end{vmatrix}}  \ \ u \in \{1, 2, ..., m\}
   $$

2. 사용자 $u, v$ 간의 피어슨 상관계수를 계산한다.
   $$
   Sim(u, v) = Pearson(u, v) = \frac{\sum_{k\in I_u \cap I_v}(r_{uk}-\mu_u)(r_{vk}-\mu_v)}{\sqrt{\sum_{k\in I_u \cap I_v}(r_{uk}-\mu_u)^2}\sqrt{\sum_{k\in I_u \cap I_v}(r_{vk}-\mu_v)^2}}
   $$

(엄밀히 말하자면 피어슨 상관계수에서 $\mu_u$는 $I_u \cap I_v$에 해당하는 item에 대한 평점에 대해서만 계산해야 하지만, 이 경우 사용자가 달라짐에 따라 다른 결과를 얻기 때문에, 계산적 이유로 인해 위와 같이 평균을 정의한다. 다만 두 가지 방법 중 어느 방법이 더 좋은지는 확실하게 이야기하기는 어렵다.)



피어슨 상관계수는 타깃 사용자와 다른 모든 사용자 간의 계산이다. 타깃 사용자의 피어 그룹을 정의하는 한 가지 방법으로는 타깃과 피어슨 상관계수가 가장 높은 $k$ 사용자 집합을 이용하는 것이다. 하지만 타깃 사용자의 상위-$k$ 피어 그룹에서 관측되는 평점의 개수는 아이템에 따라 매우 다르기 때문에, 타깃 사용자와 가장 근접한 $k$ 사용자들은 각각의 예측된 아이템에 대해 개별적으로 발견돼, 각각의 $k$ 사용자가 해당 아이템에 대해 평점을 지정한다. 이 평점의 가중 평균이 해당 아이템의 예측되는 평점이다. 여기서 각 평점은 타깃 사용자에 대한 소유자의 피어슨 상관계수로 가중치가 부여된다. (아이템마다 $k$ 사용자 중 평점을 매긴 사용자의 평점을 이용하되, 피어슨 상관계수로 가중치를 두어서 계산한다.)

이 방법론의 가장 큰 문제는 서로 다른 사용자가 평점에 각기 다른 스케일을 부여할 수 있다는 점이다. 따라서 평점 그 자체는 피어 그룹의 평균 평점을 결정하기 전에 행에 대해서 평균을 중심으로 재배열되어야 한다. 사용자 $u$의 아이템 $j$에 대한 평균 중심 평점 $s_{uj}$는 초기 평점 $r_{uj}$에서 사용자의 평균 평점을 빼는 것으로 정의할 수 있다.


$$
s_{uj} = r_{uj} - \mu_u \ \ \ u \in\{1, ..., m\}
$$


**타깃 사용자 $u$의 상위-$k$ 피어 그룹에서의 아이템에 대한 평균 중심 평점의 가중 평균을 구한 뒤, 타깃 사용자의 평균 평점이 더해져 타깃 사용자 $u$의 아이템 $j$에 대한 평점 $\hat{r}_{uj}$가 예측된다.** $P_u(j)$를 아이템 $j$에 대해 평점을 매긴 타깃 사용자 $u$의 최근접 사용자 $k$명의 집합 1이라 생각해보자. (많은 경우 타깃 사용자 $u$에 대한 아이템 $j$에 대한 관측된 평점을 보유하고 있는 유효 $k$ 피어는 없을 수 있다. 이 때 $P_u(j)$는 $k$보다 작은 원소 개수를 가지고 있을 것이다.) 타깃 사용자 $u$와 매우 낮은 아니면 음수의 상관관계를 보이는 사용자는 종종 경험적 강화 방법으로 $P_u(j)$에서 제외되기도 한다. 이 후 전체적 이웃 기반 예측함수는 다음과 같다.


$$
\hat{r}_{uj} = \mu_u + \frac{\sum_{v \in P_u(j)}  Sim(u, v)\cdot  s_{vj}}{\sum_{v \in P_u(j)}\begin{vmatrix}Sim(u, v)\end{vmatrix}} =  \mu_u + \frac{\sum_{v \in P_u(j)}Sim(u, v)\cdot (r_{vj} - \mu_v)}{\sum_{v \in P_u(j)}\begin{vmatrix}Sim(u, v)\end{vmatrix}}
$$

<br/>

*example* 



다음의 평점 행렬을 살펴보자.



|        | item 1 | item 2 | item 3 | item 4 | item 5 | item 6 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| user 1 | 7      | 6      | 7      | 4      | 5      | 4      |
| user 2 | 6      | 7      | ?      | 4      | 3      | 4      |
| user 3 | ?      | 3      | 3      | 1      | 1      | ?      |
| user 4 | 1      | 2      | 2      | 3      | 3      | 4      |
| user 5 | 1      | ?      | 1      | 2      | 3      | 3      |



타깃 사용자가 3이면, item 1과 item 6에 대한 사용자 3의 평점을 예측하려고 한다. 즉 $r_{31}, r_{36}$의 값을 예측해야 한다. 

첫 번째로, 사용자 3과 다른 사용자간의 유사도를 구해주어야 한다. 이를 구하기 위해 평균평점을 각각 구하면


$$
\mu_1 = 5.5, \ \ \mu_2 = 4.8, \ \ \mu_3 = 2, \ \ \mu_4 = 2.5, \ \ \mu_5 = 2
$$


그 후 사용자 3과 나머지 사용자간의 유사도를 구해주면 된다. 사용자 3과 사용자 1간의 유사도는 다음과 같다.


$$
Sim(user_3, user_1 ) \\  = \frac{(0.5)(1) + (1.5)(1) + (-1.5)(-1) + (-0.5)(-1)}{\sqrt{(0.5)^2 + (1.5)^2 + (-1.5)^2 + (-0.5)^2} \sqrt{(1)^2+(1)^2+(-1)^2+(-1)^2}}  = 0.894\\
$$


같은 방법으로 나머지 사용자들과의 유사도를 구하면


$$
Sim(user3, user2) = 0.939 \\
Sim(user3, user3) = 1\\
Sim(user3, user4) = -1 \\
Sim(user3, user5) = -0.817
$$


위 사용자 중 사용자 3과 가장 유사한 2명을 찾아 피어그룹으로 형성하면, user 1과 user 2가 이에 해당한다. 만든 피어 그룹을 이용하여 $r_{31}, r_{36}$을 계산하면


$$
\hat{r}_{31} = \frac{0.894 *7 + 0.939*6}{0.894 + 0.939} \approx 6.49 \\
\hat{r}_{36} =  \frac{0.894 *4 + 0.939*4}{0.894 + 0.939} = 4
$$


위와 같이 예측할경우 타깃 사용자 3이 일반적으로 부여한 평점보다 크게 높은 값을 얻는 것을 알 수 있다. 즉, 사용자가 부여하는 평점을 scaling하지 않아 생긴 bias이다. 따라서, 평균 중심으로 이동한 후 계산한 $\hat{r}_{31}, \hat{r}_{36}$은 다음과 같다.


$$
\hat{r}_{31} = 2 + \frac{0.894 * 1.5 + 0.939*1.2}{0.894 + 0.939} \approx 3.35 \\
\hat{r}_{36} = 2 + \frac{0.894 * (-1.5) + 0.939*(-0.8)}{0.894 + 0.939} \approx 0.86 \\
$$


평균 중심 scaling 이후 결과 값은 사용자 3의 평점과 평균과 비슷한 값을 가지고, 이를 통해 사용자 3에게는 아이템 6보다는 아이템 1이 추천 항목으로 우선순위가 높은 것을 알 수 있다. 다만, 현재 $\hat r_{36}$의 값은 평점으로 부여되는 값의 범위에서 벗어나기 때문에, 이를 수정하기 위해 제시된 평점 값에서 최근접 값으로 수정하여 사용하기도 한다.



<br/>

#### (1) 유사도 함수 변형

<br/>

**RawCosine** 



유사도 함수 중 하나인 cosine 함수를 사용할 때 평점 그 자체에 사용한 함수이다.


$$
RawCosine(u, v) = \frac{\sum_{k\in I_u \cap I_v}r_{uk}r_{vk}}{\sqrt{\sum_{k\in I_u \cap I_v}r^2_{uk}}\sqrt{\sum_{k\in I_u\cap I_v}r^2_{vk}}}
$$


혹은 분모의 정규화에서는 지정된 전체 아이템을 기반으로 하는 경우 또한 존재한다.


$$
RawCosine(u, v) = \frac{\sum_{k\in I_u \cap I_v}r_{uk}r_{vk}}{\sqrt{\sum_{k\in I_u}r^2_{uk}}\sqrt{\sum_{k\in I_v}r^2_{vk}}}
$$

<br/>


**DiscountedSim**



유사도 함수 $Sim(u, v)$의 신뢰도는 사용자 $u$와 $v$ 간의 공통 평점 개수 $\begin{vmatrix} I_u \cap I_v \end{vmatrix}$에 영향을 받는다. 만일 두 명의 사용자가 공통적으로 부여한 수가 적다면, 유사도 함수는 두 사용자 쌍의 중요도를 덜 강조하기 위해 할인 요인을 적용해 중요도를 낮춘다. 이를 **중요도 가중(significance weighting)**이라고 한다.

할인요인은 특정 임계값 $\beta$에 대해 다음과 같이 정의되고


$$
\frac{\min\{\begin{vmatrix}I_u \cap I_v\end{vmatrix}, \beta\}}{\beta}
$$


이를 이용한 유사도함수 $DiscountedSim(u, v)$는 다음과 같이 정의된다.


$$
DiscountedSim(u, v) = Sim(u, v) \cdot \frac{\min\{\begin{vmatrix}I_u \cap I_v\end{vmatrix}, \beta\}}{\beta}
$$

<br/>

#### (2) 예측 함수 변형

<br/>

**Z-Score**



$s_{uj}$는 평균 중심으로 평점을 이동했던 것에 반해, 이를 사용자 $u$의 관측된 평점에 대한 표준편차 $\sigma_u$로 나눠주는 z-score을 이용할 수 있다. 이 때 $\sigma_u$는 다음의 식을 이용하여 구한다.


$$
\sigma_u = \sqrt{\frac{\sum_{k\in I_u}(r_{uk}-\mu_u)^2}{\begin{vmatrix} I_u \end{vmatrix}-1}} \ \ \  u \in \{1, 2, ..., m\}
$$


따라서 $z_{uj}$는 다음과 같다.


$$
z_{uj} = \frac{s_{uj}}{\sigma_u} = \frac{r_{uj} - \mu_u}{\sigma_u}
$$


$P_u(j)$를 타깃 사용자 $u$ 의 상위-$k$명의 아이템의 평점을 기록한 유사 사용자의 집합이라고 하자. 이 경우 타깃 사용자 $u$의 아이템 $j$의 예측 평점 $\hat{r}_{uj}$는 다음과 같다.


$$
\hat r_{uj} = \mu_u + \sigma_u \frac{\sum_{v \in P_u(j)}Sim(u, v)*z_{vj}}{\sum_{v \in P_u(j)}\begin{vmatrix}Sim(u, v) \end{vmatrix}}
$$


평점 표준화 과정에서 함수 $g(\cdot)$을 더한다면 해당 함수의 역은 마지막 예측 과정에서 다시 한 번 계산되어야 하므로, $\sigma_u$를 계산과정에서 다시 곱해주어야 한다.

<br/>

 **가중치 계산**



사용자 $u$의 예측 평점을 계산할 때 나머지 사용자들과의 유사도함수를 계산하고, 그 값을 가중치로 사용한다. 이 때, 유사도 함수값을 $\alpha$의 지수로 지수화해 증폭화할 수 있다.


$$
Sim(u, v) = Pearson(u, v)^\alpha
$$




위의 경우 $\alpha >1$로 설정하면, 가중치 계산에서 유사도 중요성을 더 증폭시킬 수 있다.





이웃 기반 협업 필터링 방법론은 가까운 이웃 분류 방법론, 회귀 방법론의 일반화이다. 타깃 사용자 $u$의 피어 그룹에 대한 정의가 끝나면 피어 그룹 안에서의 각 평점 값마다의 득표수를 구할 수 있다. 가장 많은 득표를 얻은 평점이 가장 관련이 큰 값으로 예측된다. 위 방법은 평점의 종류가 적을 때 효과적이고, 서수 평점에서도 유용하게 사용된다.

<br/>

#### (3) 피어 그룹 필터링의 변형

<br/>

가장 간단한 피어 그룹 형성 방법은 타깃 사용자의 상위-$k$ 유사 사용자 그룹을 이용하는 것이다. 하지만 이 경우 음의 상관관계를 가지거나 약한 상관관계를 가지는 사용자까지 피어 그룹에 형성될 수 있기 때문에, 위 두 경우에 해당하는 사용자들은 필터링돼 제외되는 경우가 많다. 

<br/>

#### (4) Long-tail의 영향

<br/>

실제 평점 분포는 long-tail 분포를 따르는 경우가 많다. 

ex : 어떤 영화는 굉장히 유명해서 서로 다른 사용자들로부터 반복적으로 평점을 받을 수 있고, 이런 평점은 사용자간 차별성이 적기 때문에 추천 품질을 악화시킬 수 있다.

이를 해결하기 위해 역문서빈도를 활용할 수 있다.

아이템 $j$에 대한 평점 개수는 $m_j$라 하고, $m$은 총 사용자 수라면 아이템 $j$에 대한 가중치 $w_j$는 다음과 같다.


$$
w_j = \log \left(\frac{m}{m_j}\right), \ \ \ j\in\{1, 2, ..., n\}
$$


유사도 계산 과정과 추천 과정에서 모두 각각의 아이템 $j$에 대해 $w_j$의 가중치가 부여된다. 예를 들어 피어슨 상관계수의 경우 다음과 같이 변형될 수 있다.


$$
Pearson(u, v) = \frac{\sum_{k \in I_u \cap I_v}w_k(r_{uk}-\mu_u)(r_{vk}-\mu_v)}{\sqrt{\sum_{k \in I_u \cap I_v}w_k(r_{uk}-\mu_u)^2}\sqrt{\sum_{k \in I_u\cap I_v}w_k(r_{vk}-\mu_v)^2}}
$$

<br/>


#### 2) 아이템 기반 이웃 모델

<br/>

아이템 기반 모델에서의 피어 그룹은사용자가 아닌 아이템으로 구성돼 있다. 따라서 아이템 간의 유사도가 계산되어야 한다. 사용자 기반 이웃 모델에서와 마찬가지로, 평점 행렬의 **각 열은 평균 0을 중심으로 재구성된 평균 중심 행렬을 이용한다.** 

$U_i$를 아이템 $i$에 대한 평점을 지정한 사용자들의 집합이라고 하자. 아이템 $i$와 $j$와의 Adjusted Cosine 유사도는 

다음과 같다.

$$
AdjustedCosine(i, j) = \frac{\sum_{u \in U_i \cap U_j} s_{ui}\cdot s_{uj}}{\sqrt{\sum _{u\in U_i \cap U_j}s_{ui}^2} \sqrt{\sum_{u \in U_i \cap U_j } s_{uj}^2}}
$$




Cosine 값을 구할 때 평균 중심 평점을 이용하였기 때문에 adjusted cosine 유사도라고 한다. 물론 피어슨 상관 관계를 이용할 수도 있으나, adjusted cosine이 일반적으로 더 우수한 결과를 보인다.

사용자 $u$의 타깃 아이템 $t$의 평점이 결정돼야 한다고 생각해보자. 첫 번째 단계는 adjusted cosine 유사도를 기반으로 아이템 $t$와 가장 유사한 상위-$k$ 아이템들을 결정하는 일이다. 사용자 $u$가 평점을 지정한 아이템 $t$에 상위-$k$로 매칭되는 아이템들을 $Q_t(u)$라 하자. 따라서 사용자 $u$의 타깃 아이템 $t$에 대한 예측 평점 $\hat r_{ut}$는 다음과 같다.


$$
\hat r_{ut} = \frac{\sum_{j \in Q_t(u)}AdjustedCosine(j, t) r_{uj}}{\sum_{j \in Q_t(u)}\begin{vmatrix}AdjustedCosine(j, t) \end{vmatrix}}
$$

<br/>

*example*



앞서 사용자 기반 이웃 모델에서 사용한 평점 행렬을 다시 살펴보자



|        | item 1 | item 2 | item 3 | item 4 | item 5 | item 6 |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| user 1 | 7      | 6      | 7      | 4      | 5      | 4      |
| user 2 | 6      | 7      | ?      | 4      | 3      | 4      |
| user 3 | ?      | 3      | 3      | 1      | 1      | ?      |
| user 4 | 1      | 2      | 2      | 3      | 3      | 4      |
| user 5 | 1      | ?      | 1      | 2      | 3      | 3      |





위 행렬의 user 3의 item 1과 item 6에 대한 평점을 아이템 기반 이웃 모델을 통해서 예측해보자. 첫 번째로 할 일은, 각 아이템에 대한 유사도를 구하는 것이다. 먼저 평균 중심 평점을 구하기 위해 각 사용자마다의 평균 평점을 구하면 다음과 같다.


$$
\mu_1 = 5.5, \ \ \mu_2 = 4.8, \ \ \mu_3 = 2, \ \ \mu_4 = 2.5, \ \ \mu_5 = 2
$$




이를 이용해 아이템 1과 2의 adjusted cosine 유사도를 구할 수 있다.


$$
AdjustedCosine(1, 2) = \frac{1.5*0.5 + 1.2*2.2 +(-1.5)*(-0.5)}{\sqrt{1.5^2+1.2^2+(-1.5)^2}\sqrt{0.5^2+2.2^2+(-0.5)^2}} = 0.735
$$


마찬가지의 방법으로 아이템 1과 나머지 아이템간의 adjusted cosine 유사도를 다음과 같이 구할 수 있다.


$$
AdjustedCosine(1, 3) = 0.912 \\
AdjustedCosine(1, 4) = -0.848 \\
AdjustedCosine(1, 5) = -0.813\\
AdjustedCosine(1, 6) = -0.990
$$


아이템 6과 나머지 아이템간의 adjusted cosine 유사도는 다음과 같다.


$$
Adjustedcosine(6, 1) = -0.990 \\
Adjustedcosine(6, 2) = -0.622 \\
Adjustedcosine(6, 3) = -0.912 \\
Adjustedcosine(6, 4) = 0.829 \\
Adjustedcosine(6, 5) = 0.730
$$


결과를 보면 아이템1은 아이템 2와 3과 유사한 반면, 아이템 6은 아이템 4, 5와 유사한 것을 알 수 있다. 따라서 사용자 3의 아이템 2와 3에 대한 가중 평균은 아이템 1의 평점 $\hat r_{31}$을 예측하는 데 쓰이고, 사용자 3의 아이템 4와 5에 대한 가중 평균은 아이템 6의 평점 $\hat r_{36}$을 예측하는데 쓰인다.


$$
\hat r_{31} = \frac{3*0.735 + 3*0.912}{0.735+0.912} = 3\\
\hat r_{36} = \frac{1*0.829 + 1*0.730}{0.829+0.730} = 1
$$




아이템 기반 방법론으로는 아이템 1이 아이템 6보다 사용자 3에게 더 선호될 것이라는 것을 말해준다. 이 때, 자신이 준 평점에 기반하여 평점을 예측하기 때문에 해당 사용자의 다른 평점과 비슷한 결을 유지할 수 있다. 이러한 높은 예측 정확도는 가장 주요한 장점 중 하나이다. 





<br/>

#### 3) 효율적 구현 및 계산 복잡성

<br/>

이웃 기반 방법론에서는 타깃 사용자의 가장 적절한 추천 항목을 결정하는 데 쓰이거나 타깃 아이템에 대한 사용자 추천을 결정하는 데 쓰인다. 여기서 특정 아이템-사용자 조합에 대한 평점 예측만 보여줄 뿐 실제로 순위 프로세스는 설명하지 않는다. 가장 직관적으로는 관측되어 있지 않은 모든 사용자-아이템 쌍에 대해 평점을 모두 예측한 뒤 이를 가지고 순위를 매길 수 있다. 이 방법이 현재 추천 시스템에 쓰이고 있는 가장 기본적인 접근 방식이지만, 많은 사용자-아이템 조합에 대한 예측 과정이 중간 계산 과정에서도 재사용된다는 점이 중요하다. 따라서 이 중간 계산을 저장하고 순위 과정에 사용하기 위해 오프라인 단계를 사용하는 것이 좋다.

이웃 기반 방법론은 항상 오프라인 단계와 온라인 단계로 나눠진다. 오프라인 단계에서는 사용자-사용자(또는 아이템-아이템) 유사도 값과 사용자의 피어 그룹이 계산된다. 각각의 사용자(또는 아이템)에 대해 관련 있는 피어 그룹은 계산에 기초해 사전에 저장된다. 온라이 단계에서는 오프라인 단계에서 구한 유사도 값과 피어 그룹을 활용해 예측을 수행한다. 

$n' << n$을 사용자의 지정된 평점의 최대 수라 하고, $m' << m$을 아이템의 지정된 평점의 최대 수라고 하자. $n$은 한 쌍의 사용자간의 유사도를 계산하기 위한 최대 실행 시간이고, $m$은 한 쌍의 아이템 간의 유사도를 계산하기 위한 최대 실행 시간이다. 사용자 기반 방법론의 경우 타깃 사용자의 피어 그룹을 결정하는 과정에서 $O(mn')$ 시간이 요구될 수 있다.(사용자 명수 : $m$, 타깃 사용자가 평가한 평점 수 $n'$, 하나의 유사도 계산시 필요한 시간을 1이라 했을 때, 최대 $mn'$번 계산하기 때문) 따라서 모든 사용자의 피어 그룹을 계산하기 위한 오프라인 실행 시간은 $O(m^2n')$으으로 정의된다.($O(mn')$ 시간이 걸리는 과정을 $m$명의 모든 사용자에 대해서 시행해야 하기 때문) 아이템 기반 방법론에서 같은 오프라인 실행 시간은 $O(n^2m')$으로 표시된다.

$k$값을 다양하게 하는 접근 방법을 사용하려면 사용자(또는 아이템) 쌍 사이에 0이 아닌 유사도 쌍을 모두 저장해야 한다. 따라서 사용자 기반 방법론에서의 공간 요구 사항은 $O(m^2)$인 반면, 아이템 기반 방법론의 공간 요구 사항은 $O(n^2)$이다. 사용자 수는 일반적으로 아이템의 수보다 많기 때문에, 사용자 기반 방법론의 공간 요구 사항은 아이템 기반 방법론보다 대체로 크다.

예측된 값의 온라인 계산은 사용자 기반 및 아이템 기반 방법론 모두 $O(k)$에 속한다.(실제로 피어 그룹 내에 $k$명(또는 개)이 존재하기 때문). 또한 만일 예측이 랭킹을 위해 타깃 사용자의 모든 아이템에 대해서 계산돼야 하는 경우, 사용자 기반 및 아이템 기반 방법론 모두 실행 시간은 $O(kn)$이다. 그와 반대로 판매자는 특정 아이템에 대해 타깃을 지정할 상위 $r$ 사용자를 결정할수도 있다. 이 경우, 예측은 타깃 아이템에 대해 모두 랭킹을 지정해야 하기 때문에, 모든 사용자들에 대해 실행돼야 하고, 사용자 기반과 아이템 기방 방법론 모두 실행 시간은 $O(km)$이다. 



<br/>

#### 4) 사용자 기반 방법론과 아이템 기반 방법론의 비교

<br/>

아이템 기반 방법론은 사용자 자체 평점을 추천에 활용하기 때문에 더 관련성이 높은 추천을 제공한다. 아이템 기반 방법론에서는 유사 아이템을 타깃 항목으로 인지하고 그 아이템에 대한 사용자가 지정한 평점을 활용해 타깃을 평점을 추측한다. 따라서 아이템 기반 방법론이 사용자 기반 방법론보다 더 나은 정확도를 보인다.

다만, 사용자 기반 방법론은 아이템 기반 방법론보다 추천 결과가 다양해질 수 있다. 이러한 다양성은 뜻밖의 발견을 장려하고, 이를 통해 다소 놀라우면서 흥미로운 아이템이 발견된다. 아이템 기반 방법론에서는 명백한 항목을 추천해주지만, 충분한 참신함, 다양성, 우연성이 없다면 사용자는 이미 봤던 유사 추천 항목에 대해서는 지루해할 수 있다. 

아이템 기반 방법론은 추천에 구체적인 근거를 제시한다. 왜 이러한 아이템을 추천하게 되었는지 구체적으로 설명이 가능하다. 하지만 사용자 기반 방법으로는 익명의 사용자로 이루어진 피어 그룹을 이용한 추천이므로, 추천의 구체적인 근거를 제시하기는 어렵다.

사용자 기반 방법론은 여러 가지 부가적인 설명을 제공한다. 사용자의 피어 그룹이 어떤 아이템을 선호했는지 시각적으로 분석이 가능하다. 하지만 실제로 사용자와 그의 피어 그룹 간 취향이나 관련성이 어떤지는 명확하게 설명해주지 못한다. 또한 이웃이 누구인지조차 개인 정보 보호로 인해 알 수 없다.

아이템 기반 방법론은 평점의 변화에 안정적이다. 이는 첫째, 사용자 수는 대체로 아이템 수보다 크고, 둘 째, 신규 사용자는 상용 시스템에서 신규 아이템보다 더 자주 추가될 것이기 때문이다. 이는 두 사용자가 공통으로 매긴 아이템의 수는 적을 수 있으나, 두 아이템에 대해 공통으로 평점을 매긴 사용자의 수는 더 많기 때문이다. 따라서 아이템 기반 방법론은 평점의 변화에 안정적이며, 반대로 사용자 기반 방법론은 새로운 평점이 추가될 때 결과가 크게 바뀔 수 있다. 결과적으로, 아이템 기반 방법론은 가끔씩 업데이트해주어도 무방하나, 반대로 사용자 기반 방법론은 신규 사용자가 추가됨에 따라 더 자주 계산해야 한다. 그러므로 사용자 기반 방법론을 기반으로 한 추천 모델은 점진적 유지 관리가 더 어려워진다.



<br/>

#### 5) 이웃 기반 방법론의 장점과 단점

<br/>

이웃 기반 방법론은 단순함과 직관적인 성격 때문에 적용하기도 쉽고 문제를 파악하기도 쉽다. 왜 특정 아이템이 추천됐는지 알기도 쉽고, 아이템 기반 방법론의 해석 가능성은 특히 주목할 만하다. 또한 추천은 신규 아이템과 사용자가 추천되는 경우 상대적으로 안정적이다. 이 방법론의 점증적 근사도 가능하다.

가장 큰 단점은 대규모 환경에서 오프라인 단계가 가지는 비효율성이다. 사용자 기반 방법론의 오프라인 단계는 적어도 $O(m^2)$ 시간과 공간이 필요하다. $m$이 수천만에 달하는 경우 데스크톱 하드웨어에서 너무 느리거나 공간에 영향을 많이 받는다. 다만, 이웃 방법론의 온라인 단계에서는 항상 효율적이다.

또 다른 주요 단점은 희박함에 생긴 제한된 커버리지이다. 대부분의 추천 환경에서는 사용자의 상위-$k$ 아이템에만 관심을 가지는데, 다른 사용자들이 특정 아이템을 평가하지 않은 경우 해당 아이템에 대한 평점 예측은 불가능하다. 희박함(sparsity)은 두 사용자가 공통적으로 평가한 아이템의 숫자가 적다면 robust한 유사도 값 계산은 어렵다.

<br/>

#### 6) 사용자 기반과 아이템 기반 방법론의 통합된 관점

<br/>

사용자 기반 및 아이템 기반 방법론 각각의 단점은 전자는 평점 행렬의 열간의 유사도를 무시하는 반면, 후자는 가장 비슷한 엔트리를 결정할 때 행간의 유사도를 무시한다. 이를 해결하기 위해 유사도를 구할 때 두 가지 방법론은 통합하여 계산할 수 있다.

이를 이루기 위해서는 일단 열이 평균 중심으로 설정되면 사용자 기반과 아이템 기반 방법론이 거의 같다는 것을 이해해야 한다. 일반성의 손실 없이 평점 행렬의 열을 평균 중심으로 설정할 수 있고, 예측 후에 각 엔트리에 각 열의 평균을 더할 수 있기 때문이다. 또한 열시 평균 중심이면 열간의 피어슨 상관계수는 코사인 계수와 동일하다. 이를 이용하여 사용자 기반과 아이템 기반 방법론을 통합해 평점 행렬 $R$의 엔트리 $r_{uj}$를 예측할 수 있다.

1. 행과 열간의 코사인 계수를 이용해 평점 행렬의 타깃 엔트리 $(u, j)$와 가장 유사한 행, 열을 결정한다.
2. 위의 단계에서 찾은 행과 열의 평점의 가중 조합을 이용해 타깃 엔트리 $(u, j)$ 를 예측한다.



또는 행과 열에 따른 예측 정보와 유사도가 결합되는 일반적인 컨텍스트를 제시할 수 있다.

1. 행과 열간의 유사도 조합을 이용해 평점 행렬에서 타깃 엔트리 $(u, j)$의 가장 비슷한 엔트리를 결정한다. 예를 들어 행간 혹은 열간의 코사인 유사도의 합을 이용해, 평점 행렬의 가장 유사한 $(u, j)$를 결정할 수 있다.
2. 1번째 단계에서 결정한 엔트리 값에서 가중 조합을 이용해 타깃 엔트리 $(u, j)$를 예측한다.



